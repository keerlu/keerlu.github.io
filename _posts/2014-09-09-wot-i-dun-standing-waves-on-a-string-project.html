---
layout: post
title: ! 'Wot i dun: standing waves on a string project'
date: 2014-09-09 17:51:13.000000000 +01:00
categories: []
tags: []
status: draft
type: post
published: false
meta:
  _edit_last: '67112767'
  _wpcom_is_markdown: '1'
author:
  login: wotidun
  email: wotidunread@gmail.com
  display_name: wotidun
  first_name: ''
  last_name: ''
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<h1>Intro</h1>
<p>Originally inspired to try Pygame for physics visualisations by <a href="Intro">Peter Collingwood's excellent physics tutorials</a> which I worked through a while ago to start getting the idea of Python. I'm not too sure it's the best tool for producing the kind of thing I want (I will definitely be considering redoing this particular project as an interactive web visualisation in d3.js), but it's been good for starting to learn the language.</p>
<p>=====</p>
<p>Originally inspired to try Pygame for physics visualisations by <a href="Intro">Peter Collingwood's excellent physics tutorials</a> which I worked through a while ago to start getting the idea of Python. I'm not too sure it's the best tool for producing the kind of thing I want (I will definitely be considering redoing this particular project as an interactive web visualisation in d3.js), but it's been good for starting to learn the language.</p>
<p><a href="Intro">collingwood</a>:</p>
<p>My original idea for a Pygame project was to produce some demonstrations relating to <a href="http://en.wikipedia.org/wiki/Weak_measurement">weak measurements in quantum mechanics,</a> a subject I'm currently trying to learn more about. Despite the rather dry and factual name, the theory of weak measurement has led to all kinds of strange experiments that are bizarre even by quantum standards (e.g. the recent <a href="http://www.bbc.co.uk/news/science-environment-28543990">Quantum Cheshire Cat experiment</a>). In particular, I wanted to create my own version of the model in <a href="mafija.fmf.uni-lj.si/seminar/files/2012_2013/Weak_koncni.pdf">this master's project paper</a>. I have a few notes on this, but mainly I just found myself going down the rabbit hole of trying to understand weak measurement and not doing much coding.</p>
<p>Then I got a temp job for a couple of months, scanning and sorting post in a law firm, so I decided to give weak measurement a rest for a bit and pick a relatively straightforward project that I could work on half asleep in the library some evenings (I wanted to be able to say I done <em>something</em> with my week other than scanning post). I still wanted something physics-y, so decided to make my own version of this nice <a href="http://www.phy.hk/wiki/englishhtm/StatWave.htm">Java applet</a> I'd come across demonstrating resonance on a string as the frequency of vibration changes.</p>
<p>The maths is in a pdf <a href="phy.hk/wiki/applets/StatWave/WaveOnRope.pdf">here</a> -- the main reason I picked this project is that I hadn't actually seen this exact problem solved before, with the oscillating boundary for the string. I started by just using Pygame to model the function given in the pdf (which is pretty terse) and only thought about deriving the maths for myself later.</p>
<p>!!add contents page</p>
<h1>Monday 18th August</h1>
<p>First I found a <a href="http://ericeastwood.com/blog/7/animated-sine-wave-two-ways-with-pygame-and-tkinter">similar pygame project</a> that just plots an animated sine wave running, so that I had something to build on. This took a while as I only had my netbook on me, which was missing pygame and some other stuff... but I got it working.</p>
<p>Then I mucked about for a while, trying to implement the function inside the sum in the <a href="phy.hk/wiki/applets/StatWave/WaveOnRope.pdf">pdf</a>, i.e.</p>
<p>!! insert maths here<br />
It didn't quite work, but that was enough for one evening.</p>
<h1>Tuesday 19th August</h1>
<p>I found my silly errors from the previous day and got going. I ended up with this function definition (I don't want damping... !!should have explained in maths)</p>
<p>[code lang=text]<br />
&lt;br /&gt;# Define standing wave function</p>
<p>amplitude = 50 # in px<br />
speed = 1</p>
<p>def k(n):<br />
    return n*math.pi/canvas_width</p>
<p>def ysummand(x, n, frequency):<br />
    return (frequency**2/(k(n)**2-frequency**2))*math.sin(k(n)*(float(x)))*math.cos(frequency*(speed*time.time()))</p>
<p>def ysum(x, frequency):<br />
    for i in range (1, 10):<br />
        sum = 0<br />
        sum = sum + ysummand(x, i, frequency)<br />
        return sum</p>
<p># some more irrelevant stuff...</p>
<p>for x in range(0, canvas_width):<br />
    y = int((canvas_height/2) + amplitude*ysum(x, 12))<br />
        surface.set_at((x, y), color)</p>
<p>[/code]</p>
<p>Seems to work nicely, as far as I can tell by just playing with different numbers for the frequency! Will be able to test it better once I've implemented some kind of interactive way to change the frequency... that is definitely a problem for another day when I'm less tired.</p>
<p>Then I remembered I need psi... I started to add this, ending up with:</p>
<p>[code lang=text]<br />
&lt;br /&gt;import pygame<br />
import time<br />
import math</p>
<p># Some config width height settings<br />
canvas_width = 640<br />
canvas_height = 480</p>
<p># Just define some colors we can use<br />
color = pygame.Color(255, 255, 0, 0)<br />
background_color = pygame.Color(0, 0, 0, 0)</p>
<p>pygame.init()<br />
# Set the window title<br />
pygame.display.set_caption(&quot;Standing wave demonstration&quot;)</p>
<p># Make a screen to see<br />
screen = pygame.display.set_mode((canvas_width, canvas_height))<br />
screen.fill(background_color)</p>
<p># Make a surface to draw on<br />
surface = pygame.Surface((canvas_width, canvas_height))<br />
surface.fill(background_color)</p>
<p># Define standing wave function</p>
<p>amplitude = 50 # in px<br />
speed = 1</p>
<p>def k(n):<br />
    return n*math.pi/canvas_width</p>
<p>def ysummand(x, n, frequency):<br />
    return (frequency**2/(k(n)**2-frequency**2))*math.sin(k(n)*(float(x)))*math.cos(frequency*(speed*time.time()))</p>
<p>def ysum(x, frequency):<br />
    for i in range (1, 10):<br />
        sum = 0<br />
        sum = sum + ysummand(x, i, frequency)<br />
        return sum</p>
<p>def y(x, frequency):<br />
    return int((2/math.pi)*amplitude*ysum(x, frequency))</p>
<p> #      y = int((canvas_height/2) + amplitude*math.sin(frequency*((float(x)/canvas_width)*(2*math.pi) + (speed*time.time()))))</p>
<p># Simple main loop<br />
running = True<br />
while running:<br />
    for event in pygame.event.get():<br />
        if event.type == pygame.QUIT:<br />
            running = False</p>
<p>    # Redraw the background<br />
    surface.fill(background_color)</p>
<p>    for x in range(0, canvas_width):<br />
    psi = int((canvas_height/2) + y(x, 3) + (1 - (x/canvas_width))*amplitude*math.cos(3*(speed*time.time())))<br />
        surface.set_at((x, psi), color)</p>
<p>    # Put the surface we draw on, onto the screen<br />
    screen.blit(surface, (0, 0))</p>
<p>    # Show it.<br />
    pygame.display.flip()</p>
<p>pygame.quit ()</p>
<p>[/code]</p>
<p>This is definitely broken (the right end isn't fixed and should be), but I am tired and hungry so will leave it there for now.</p>
<h1>Thursday 21st August</h1>
<p>Tidied the code up a bit and got it working in the process (`standing_wave_1.py'). Here it is:</p>
<p>[code lang=python]<br />
&lt;br /&gt;import pygame<br />
import time<br />
import math</p>
<p># Size of window<br />
canvas_width = 640<br />
canvas_height = 480</p>
<p># Define colours<br />
color = pygame.Color(255, 255, 0, 0)<br />
background_color = pygame.Color(0, 0, 0, 0)</p>
<p>pygame.init()<br />
# Set the window title<br />
pygame.display.set_caption(&quot;Standing wave demonstration&quot;)</p>
<p># Make a screen to see<br />
screen = pygame.display.set_mode((canvas_width, canvas_height))<br />
screen.fill(background_color)</p>
<p># Make a surface to draw on<br />
surface = pygame.Surface((canvas_width, canvas_height))<br />
surface.fill(background_color)</p>
<p># Define standing wave function</p>
<p>amplitude = 50 # in px<br />
speed = 1</p>
<p>def k(n):<br />
    return n*math.pi/canvas_width</p>
<p>def ysummand(x, n, frequency):<br />
    return (frequency**2/(k(n)**2-frequency**2))*math.sin(k(n)*(float(x)))*math.cos(frequency*(speed*time.time()))</p>
<p>def ysum(x, frequency):<br />
    for i in range (1, 10):<br />
        sum = 0<br />
        sum = sum + ysummand(x, i, frequency)<br />
        return sum</p>
<p>def y(x, frequency):<br />
    return (2/math.pi)*amplitude*ysum(x, frequency)</p>
<p>def psi(x, frequency):<br />
    return y(x, frequency) + amplitude*(1 - (float(x)/canvas_width))*math.cos(frequency*(speed*time.time()))</p>
<p># Main loop<br />
running = True<br />
while running:<br />
    for event in pygame.event.get():<br />
        if event.type == pygame.QUIT:<br />
            running = False</p>
<p>    screen.blit(surface, (0, 0))</p>
<p>    # Display<br />
    pygame.display.fliphttp://www.pygame.org/docs/ref/draw.html()</p>
<p>pygame.quit ()</p>
<p>[/code]</p>
<h1>Sunday 24th August</h1>
<p>Now the maths is sorted, want to make the animation look prettier. This involves changing the colours (easy) and the thickness of the curve (not quite so easy, as the very simple code I followed worked by changing the colour of single pixels). Time to use the draw function, following this <a href="http://www.pygame.org/docs/ref/draw.html">Pygame drawing tutorial</a> to rewrite code.</p>
<p>First I made a simple sine curve (<code>drawsin.py</code>):</p>
<p>[code lang=python]<br />
&lt;br /&gt;# Draw sine curve with pygame</p>
<p>import pygame<br />
import time<br />
import math</p>
<p># Window size<br />
canvas_width = 640<br />
canvas_height = 480</p>
<p># Define colours<br />
line_colour = pygame.Color(55, 115, 212, 0)<br />
background_colour = pygame.Color(255, 255, 255, 0)</p>
<p># Make screen<br />
screen = pygame.display.set_mode((canvas_width, canvas_height))<br />
screen.fill(background_colour)</p>
<p># Sine curve properties:<br />
amplitude = 80</p>
<p>xpoints = [i for i in range(canvas_width)]<br />
ypoints = []<br />
for x in xpoints:<br />
    ypoints.append(int((canvas_height/2) + amplitude*math.sin((float(x)/canvas_width)*2*math.pi)))</p>
<p>coords = []<br />
for i in range(canvas_width):<br />
    coords.append([xpoints[i], ypoints[i]])</p>
<p>print ypoints[1:10]</p>
<p># Main loop<br />
running = True<br />
while running:<br />
    for event in pygame.event.get():<br />
        if event.type == pygame.QUIT:<br />
            running = False</p>
<p># Draw sine curve</p>
<p>    pygame.draw.lines(screen, line_colour, False, coords, 3)</p>
<p>    pygame.display.flip()   </p>
<p>pygame.quit()</p>
<p>[/code]</p>
<p>Then I added this to my file (<code>standing_wave_2.py</code>):</p>
<p>[code lang=python]<br />
&lt;br /&gt;## Standing wave demonstration with pygame</p>
<p>import pygame<br />
import time<br />
import math</p>
<p># Window size<br />
canvas_width = 640<br />
canvas_height = 480</p>
<p># Define colours<br />
line_colour = pygame.Color(55, 115, 212, 0)<br />
background_colour = pygame.Color(255, 255, 255, 0)</p>
<p># Make screen<br />
screen = pygame.display.set_mode((canvas_width, canvas_height))<br />
screen.fill(background_colour)</p>
<p># Make drawing surface<br />
surface = pygame.Surface((canvas_width, canvas_height))<br />
surface.fill(background_colour)</p>
<p># Define standing wave function</p>
<p>amplitude = 50 # in px<br />
speed = 1</p>
<p>def k(n):<br />
    return n*math.pi/canvas_width</p>
<p>def ysummand(x, n, frequency):<br />
    return (frequency**2/(k(n)**2-frequency**2))*math.sin(k(n)*(float(x)))*math.cos(frequency*(speed*time.time()))</p>
<p>def ysum(x, frequency):<br />
    for i in range (1, 10):<br />
        sum = 0<br />
        sum = sum + ysummand(x, i, frequency)<br />
        return sum</p>
<p>def y(x, frequency):<br />
    return (2/math.pi)*amplitude*ysum(x, frequency)</p>
<p>def psi(x, frequency):<br />
    return y(x, frequency) + amplitude*(1 - (float(x)/canvas_width))*math.cos(frequency*(speed*time.time()))</p>
<p># Main loop<br />
running = True<br />
while running:<br />
    for event in pygame.event.get():<br />
        if event.type == pygame.QUIT:<br />
            running = False</p>
<p>    # Redraw background<br />
    surface.fill(background_colour)</p>
<p>    xpoints = [i for i in range(canvas_width)]<br />
    ypoints = []<br />
    for x in xpoints:<br />
        ypoints.append(int((canvas_height/2) + psi(x,32)))</p>
<p>    coords = []<br />
    for i in range(len(xpoints)):<br />
        coords.append([xpoints[i], ypoints[i]])</p>
<p>    # Draw curve<br />
    pygame.draw.lines(surface, line_colour, False, coords, 3)</p>
<p>    # Add surface to screen<br />
        screen.blit(surface, (0, 0))</p>
<p>    pygame.display.flip()   </p>
<p>pygame.quit()</p>
<p>[/code]</p>
<p>It works fine, but it's kind of slow... after a bit of searching around decided to go back to the pixel-updating method of the example I followed. Here's the code (<code>standing_wave_4.py</code>):</p>
<p>[code lang=python]<br />
&lt;br /&gt;## Standing wave demonstration with pygame</p>
<p>import pygame<br />
import time<br />
import math</p>
<p># Window size<br />
canvas_width = 640<br />
canvas_height = 480</p>
<p># Define colours<br />
line_colour = pygame.Color(55, 115, 212, 0)<br />
background_colour = pygame.Color(255, 255, 255, 0)</p>
<p># Make screen<br />
screen = pygame.display.set_mode((canvas_width, canvas_height))<br />
screen.fill(background_colour)</p>
<p># Make drawing surface<br />
surface = pygame.Surface((canvas_width, canvas_height)).convert()<br />
surface.fill(background_colour)</p>
<p># Define standing wave function</p>
<p>amplitude = 50 # in px<br />
frequency = 45</p>
<p>def k(n):<br />
    return n*math.pi/canvas_width</p>
<p>def ysummand(x, n):<br />
    return (frequency**2/(k(n)**2-frequency**2))*math.sin(k(n)*(float(x)))</p>
<p>def ysum(x):<br />
    for i in range (1, 10):<br />
        sum = 0<br />
        sum = sum + ysummand(x, i)<br />
        return sum</p>
<p>def y(x):<br />
    return (2/math.pi)*amplitude*ysum(x)</p>
<p>def psi(x):<br />
    return y(x) + amplitude*(1 - (float(x)/canvas_width))</p>
<p>#pygame.init()</p>
<p># Main loop<br />
running = True<br />
while running:<br />
    for event in pygame.event.get():<br />
        if event.type == pygame.QUIT:<br />
            running = False</p>
<p>    # Redraw background<br />
    surface.fill(background_colour)</p>
<p>    for xrange in range(0, canvas_width):<br />
    yrange = int((canvas_height/2) + psi(xrange)*math.cos(frequency*time.time()))<br />
    for i in range(0, 4):<br />
        surface.set_at((xrange, yrange + i), line_colour)</p>
<p>    # Add surface to screen<br />
    screen.blit(surface, (0, 0))</p>
<p>    # Display<br />
    pygame.display.flip()   </p>
<p>pygame.quit()</p>
<p>[/code]</p>
<p>Works OK. Next need to add some interactivity.</p>
<h1>Tuesday 26th August</h1>
<p>Added some very crude interactivity: use left and right arrows to control frequency (using <a href="http://stackoverflow.com/questions/16044229/how-to-get-keyboard-input-in-pygame">this example</a> as a guide), plus some text at the top of the screen displaying the current frequency (based on <a href="http://www.pygame.org/docs/tut/tom/games2.html">this example</a>).</p>
<p>The full code is (<code>standing_wave_5.py</code>):</p>
<p>[code lang=python]<br />
&lt;br /&gt;## Standing wave demonstration with pygame</p>
<p>import pygame<br />
import time<br />
import math</p>
<p># Window size<br />
canvas_width = 640<br />
canvas_height = 480</p>
<p># Define colours<br />
line_colour = pygame.Color(55, 115, 212, 0)<br />
background_colour = pygame.Color(255, 255, 255, 0)<br />
slider_colour = pygame.Color(0, 0, 0, 0)</p>
<p># Make screen<br />
screen = pygame.display.set_mode((canvas_width, canvas_height))<br />
screen.fill(background_colour)</p>
<p># Make drawing surface<br />
surface = pygame.Surface((canvas_width, canvas_height)).convert()<br />
surface.fill(background_colour)</p>
<p># Define standing wave function</p>
<p>amplitude = 80 # in px<br />
frequency = 200<br />
speed = 0.1</p>
<p>def k(n):<br />
    return n*math.pi/canvas_width</p>
<p>def ysummand(x, n):<br />
    return (frequency**2/(k(n)**2-frequency**2))*math.sin(k(n)*(float(x)))</p>
<p>def ysum(x):<br />
    for i in range (1, 10):<br />
        sum = 0<br />
        sum = sum + ysummand(x, i)<br />
        return sum</p>
<p>def y(x):<br />
    return (2/math.pi)*amplitude*ysum(x)</p>
<p>def psi(x):<br />
    return y(x) + amplitude*(1 - (float(x)/canvas_width))</p>
<p>pygame.init()</p>
<p># Main loop<br />
running = True<br />
while running:<br />
    for event in pygame.event.get():<br />
        if event.type == pygame.QUIT:<br />
            running = False</p>
<p>    # Redraw background<br />
    surface.fill(background_colour)</p>
<p>    for xrange in range(0, canvas_width):<br />
    yrange = int((canvas_height/2) + psi(xrange)*math.cos(speed*frequency*time.time()))<br />
    for i in range(0, 4):<br />
        surface.set_at((xrange, yrange + i), line_colour)</p>
<p>    # Display some text<br />
    font = pygame.font.Font(None, 36)<br />
    text = font.render(&quot;Frequency is &quot;+str(abs(frequency)), 1, (10, 10, 10))<br />
    textpos = text.get_rect()<br />
    textpos.centerx = surface.get_rect().centerx<br />
    surface.blit(text, textpos)</p>
<p>    # Add surface to screen<br />
    screen.blit(surface, (0, 0))</p>
<p>    # Display<br />
    pygame.display.flip()</p>
<p>    move_ticker = 0<br />
    keys=pygame.key.get_pressed()<br />
    if keys[pygame.K_LEFT]:<br />
        if move_ticker == 0:<br />
            move_ticker = 10<br />
            frequency -= 0.1<br />
    if keys[pygame.K_RIGHT]:<br />
        if move_ticker == 0:<br />
            move_ticker = 10<br />
            frequency += 0.1</p>
<p>pygame.quit()</p>
<p>[/code]</p>
<p>Took a screenshot (<code>screenshot1</code>)<br />
This could do with some improvements:</p>
<ul>
<li>make it easier to change the frequency a large amount... maybe an editable text box</li>
<li>at the moment when I change the frequency the curve is 'resetting' somehow so that the movement is not smooth.</li>
</ul>
<h1>Thursday 28 September</h1>
<p>calculations</p>
<h1>Monday 1 September</h1>
<p>wrote intro<br />
played with gui library</p>
<h1>Tuesday 2 September</h1>
<p>Bit more playing with gui library, went home early as getting a cold.<br />
Not really sure this is the way I want to go.</p>
<h1>Sunday 7th September</h1>
<p>Realised code was wrong - curve wasn't changing shape with increasing frequency<br />
found one problem - ysummand was not summing correctly and fixed that. still wrong tho.</p>
<p>tested in Mathematica and convinced myself the solution was correct - just not my implementation!</p>
<h1>Monday 8th September</h1>
<p>Found problem after testing various things - something to do with integers and floats. Currently if the frequency increment is a float it breaks, if it is an integer it doesn't. Can also break it by defining the amplitude and speed as floats. Need to go through carefully and work out what needs to be what - tomorrow!</p>
<p>My original idea for a Pygame project was to produce some demonstrations relating to <a href="http://en.wikipedia.org/wiki/Weak_measurement">weak measurements in quantum mechanics,</a> a subject I'm currently trying to learn more about. Despite the rather dry and factual name, the theory of weak measurement has led to all kinds of strange experiments that are bizarre even by quantum standards (e.g. the recent <a href="http://www.bbc.co.uk/news/science-environment-28543990">Quantum Cheshire Cat experiment</a>). In particular, I wanted to create my own version of the model in <a href="mafija.fmf.uni-lj.si/seminar/files/2012_2013/Weak_koncni.pdf">this master's project paper</a>. I have a few notes on this, but mainly I just found myself going down the rabbit hole of trying to understand weak measurement and not doing much coding.</p>
<p>Then I got a temp job for a couple of months, scanning and sorting post in a law firm, so I decided to give weak measurement a rest for a bit and pick a relatively straightforward project that I could work on half asleep in the library some evenings (I wanted to be able to say I done <em>something</em> with my week other than scanning post). I still wanted something physics-y, so decided to make my own version of this nice <a href="http://www.phy.hk/wiki/englishhtm/StatWave.htm">Java applet</a> I'd come across demonstrating resonance on a string as the frequency of vibration changes.</p>
<p>The maths is in a pdf <a href="phy.hk/wiki/applets/StatWave/WaveOnRope.pdf">here</a> -- the main reason I picked this project is that I hadn't actually seen this exact problem solved before, with the oscillating boundary for the string. I started by just using Pygame to model the function given in the pdf (which is pretty terse) and only thought about deriving the maths for myself later.</p>
<p>!!add contents page</p>
<h1>Monday 18th August</h1>
<p>First I found a <a href="http://ericeastwood.com/blog/7/animated-sine-wave-two-ways-with-pygame-and-tkinter">similar pygame project</a> that just plots an animated sine wave running, so that I had something to build on. This took a while as I only had my netbook on me, which was missing pygame and some other stuff... but I got it working.</p>
<p>Then I mucked about for a while, trying to implement the function inside the sum in the <a href="phy.hk/wiki/applets/StatWave/WaveOnRope.pdf">pdf</a>, i.e.</p>
<p>!! insert maths here<br />
It didn't quite work, but that was enough for one evening.</p>
<h1>Tuesday 19th August</h1>
<p>I found my silly errors from the previous day and got going. I ended up with this function definition (I don't want damping... !!should have explained in maths)</p>
<p>[code lang=text]<br />
&lt;br /&gt;# Define standing wave function</p>
<p>amplitude = 50 # in px<br />
speed = 1</p>
<p>def k(n):<br />
    return n*math.pi/canvas_width</p>
<p>def ysummand(x, n, frequency):<br />
    return (frequency**2/(k(n)**2-frequency**2))*math.sin(k(n)*(float(x)))*math.cos(frequency*(speed*time.time()))</p>
<p>def ysum(x, frequency):<br />
    for i in range (1, 10):<br />
        sum = 0<br />
        sum = sum + ysummand(x, i, frequency)<br />
        return sum</p>
<p># some more irrelevant stuff...</p>
<p>for x in range(0, canvas_width):<br />
    y = int((canvas_height/2) + amplitude*ysum(x, 12))<br />
        surface.set_at((x, y), color)</p>
<p>[/code]</p>
<p>Seems to work nicely, as far as I can tell by just playing with different numbers for the frequency! Will be able to test it better once I've implemented some kind of interactive way to change the frequency... that is definitely a problem for another day when I'm less tired.</p>
<p>Then I remembered I need psi... I started to add this, ending up with:</p>
<p>[code lang=text]<br />
&lt;br /&gt;import pygame<br />
import time<br />
import math</p>
<p># Some config width height settings<br />
canvas_width = 640<br />
canvas_height = 480</p>
<p># Just define some colors we can use<br />
color = pygame.Color(255, 255, 0, 0)<br />
background_color = pygame.Color(0, 0, 0, 0)</p>
<p>pygame.init()<br />
# Set the window title<br />
pygame.display.set_caption(&quot;Standing wave demonstration&quot;)</p>
<p># Make a screen to see<br />
screen = pygame.display.set_mode((canvas_width, canvas_height))<br />
screen.fill(background_color)</p>
<p># Make a surface to draw on<br />
surface = pygame.Surface((canvas_width, canvas_height))<br />
surface.fill(background_color)</p>
<p># Define standing wave function</p>
<p>amplitude = 50 # in px<br />
speed = 1</p>
<p>def k(n):<br />
    return n*math.pi/canvas_width</p>
<p>def ysummand(x, n, frequency):<br />
    return (frequency**2/(k(n)**2-frequency**2))*math.sin(k(n)*(float(x)))*math.cos(frequency*(speed*time.time()))</p>
<p>def ysum(x, frequency):<br />
    for i in range (1, 10):<br />
        sum = 0<br />
        sum = sum + ysummand(x, i, frequency)<br />
        return sum</p>
<p>def y(x, frequency):<br />
    return int((2/math.pi)*amplitude*ysum(x, frequency))</p>
<p> #      y = int((canvas_height/2) + amplitude*math.sin(frequency*((float(x)/canvas_width)*(2*math.pi) + (speed*time.time()))))</p>
<p># Simple main loop<br />
running = True<br />
while running:<br />
    for event in pygame.event.get():<br />
        if event.type == pygame.QUIT:<br />
            running = False</p>
<p>    # Redraw the background<br />
    surface.fill(background_color)</p>
<p>    for x in range(0, canvas_width):<br />
    psi = int((canvas_height/2) + y(x, 3) + (1 - (x/canvas_width))*amplitude*math.cos(3*(speed*time.time())))<br />
        surface.set_at((x, psi), color)</p>
<p>    # Put the surface we draw on, onto the screen<br />
    screen.blit(surface, (0, 0))</p>
<p>    # Show it.<br />
    pygame.display.flip()</p>
<p>pygame.quit ()</p>
<p>[/code]</p>
<p>This is definitely broken (the right end isn't fixed and should be), but I am tired and hungry so will leave it there for now.</p>
<h1>Thursday 21st August</h1>
<p>Tidied the code up a bit and got it working in the process (`standing_wave_1.py'). Here it is:</p>
<p>[code lang=python]<br />
&lt;br /&gt;import pygame<br />
import time<br />
import math</p>
<p># Size of window<br />
canvas_width = 640<br />
canvas_height = 480</p>
<p># Define colours<br />
color = pygame.Color(255, 255, 0, 0)<br />
background_color = pygame.Color(0, 0, 0, 0)</p>
<p>pygame.init()<br />
# Set the window title<br />
pygame.display.set_caption(&quot;Standing wave demonstration&quot;)</p>
<p># Make a screen to see<br />
screen = pygame.display.set_mode((canvas_width, canvas_height))<br />
screen.fill(background_color)</p>
<p># Make a surface to draw on<br />
surface = pygame.Surface((canvas_width, canvas_height))<br />
surface.fill(background_color)</p>
<p># Define standing wave function</p>
<p>amplitude = 50 # in px<br />
speed = 1</p>
<p>def k(n):<br />
    return n*math.pi/canvas_width</p>
<p>def ysummand(x, n, frequency):<br />
    return (frequency**2/(k(n)**2-frequency**2))*math.sin(k(n)*(float(x)))*math.cos(frequency*(speed*time.time()))</p>
<p>def ysum(x, frequency):<br />
    for i in range (1, 10):<br />
        sum = 0<br />
        sum = sum + ysummand(x, i, frequency)<br />
        return sum</p>
<p>def y(x, frequency):<br />
    return (2/math.pi)*amplitude*ysum(x, frequency)</p>
<p>def psi(x, frequency):<br />
    return y(x, frequency) + amplitude*(1 - (float(x)/canvas_width))*math.cos(frequency*(speed*time.time()))</p>
<p># Main loop<br />
running = True<br />
while running:<br />
    for event in pygame.event.get():<br />
        if event.type == pygame.QUIT:<br />
            running = False</p>
<p>    # Redraw background<br />
    surface.fill(background_color)</p>
<p>    for xrange in range(0, canvas_width):<br />
    yrange = int((canvas_height/2) + psi(xrange, 23))<br />
        surface.set_at((xrange, yrange), color)</p>
<p>    # Add surface to screen<br />
    screen.blit(surface, (0, 0))</p>
<p>    # Display<br />
    pygame.display.fliphttp://www.pygame.org/docs/ref/draw.html()</p>
<p>pygame.quit ()</p>
<p>[/code]</p>
<h1>Sunday 24th August</h1>
<p>Now the maths is sorted, want to make the animation look prettier. This involves changing the colours (easy) and the thickness of the curve (not quite so easy, as the very simple code I followed worked by changing the colour of single pixels). Time to use the draw function, following this <a href="http://www.pygame.org/docs/ref/draw.html">Pygame drawing tutorial</a> to rewrite code.</p>
<p>First I made a simple sine curve (<code>drawsin.py</code>):</p>
<p>[code lang=python]<br />
&lt;br /&gt;# Draw sine curve with pygame</p>
<p>import pygame<br />
import time<br />
import math</p>
<p># Window size<br />
canvas_width = 640<br />
canvas_height = 480</p>
<p># Define colours<br />
line_colour = pygame.Color(55, 115, 212, 0)<br />
background_colour = pygame.Color(255, 255, 255, 0)</p>
<p># Make screen<br />
screen = pygame.display.set_mode((canvas_width, canvas_height))<br />
screen.fill(background_colour)</p>
<p># Sine curve properties:<br />
amplitude = 80</p>
<p>xpoints = [i for i in range(canvas_width)]<br />
ypoints = []<br />
for x in xpoints:<br />
    ypoints.append(int((canvas_height/2) + amplitude*math.sin((float(x)/canvas_width)*2*math.pi)))</p>
<p>coords = []<br />
for i in range(canvas_width):<br />
    coords.append([xpoints[i], ypoints[i]])</p>
<p>print ypoints[1:10]</p>
<p># Main loop<br />
running = True<br />
while running:<br />
    for event in pygame.event.get():<br />
        if event.type == pygame.QUIT:<br />
            running = False</p>
<p># Draw sine curve</p>
<p>    pygame.draw.lines(screen, line_colour, False, coords, 3)</p>
<p>    pygame.display.flip()   </p>
<p>pygame.quit()</p>
<p>[/code]</p>
<p>Then I added this to my file (<code>standing_wave_2.py</code>):</p>
<p>[code lang=python]<br />
&lt;br /&gt;## Standing wave demonstration with pygame</p>
<p>import pygame<br />
import time<br />
import math</p>
<p># Window size<br />
canvas_width = 640<br />
canvas_height = 480</p>
<p># Define colours<br />
line_colour = pygame.Color(55, 115, 212, 0)<br />
background_colour = pygame.Color(255, 255, 255, 0)</p>
<p># Make screen<br />
screen = pygame.display.set_mode((canvas_width, canvas_height))<br />
screen.fill(background_colour)</p>
<p># Make drawing surface<br />
surface = pygame.Surface((canvas_width, canvas_height))<br />
surface.fill(background_colour)</p>
<p># Define standing wave function</p>
<p>amplitude = 50 # in px<br />
speed = 1</p>
<p>def k(n):<br />
    return n*math.pi/canvas_width</p>
<p>def ysummand(x, n, frequency):<br />
    return (frequency**2/(k(n)**2-frequency**2))*math.sin(k(n)*(float(x)))*math.cos(frequency*(speed*time.time()))</p>
<p>def ysum(x, frequency):<br />
    for i in range (1, 10):<br />
        sum = 0<br />
        sum = sum + ysummand(x, i, frequency)<br />
        return sum</p>
<p>def y(x, frequency):<br />
    return (2/math.pi)*amplitude*ysum(x, frequency)</p>
<p>def psi(x, frequency):<br />
    return y(x, frequency) + amplitude*(1 - (float(x)/canvas_width))*math.cos(frequency*(speed*time.time()))</p>
<p># Main loop<br />
running = True<br />
while running:<br />
    for event in pygame.event.get():<br />
        if event.type == pygame.QUIT:<br />
            running = False</p>
<p>    # Redraw background<br />
    surface.fill(background_colour)</p>
<p>    xpoints = [i for i in range(canvas_width)]<br />
    ypoints = []<br />
    for x in xpoints:<br />
        ypoints.append(int((canvas_height/2) + psi(x,32)))</p>
<p>    coords = []<br />
    for i in range(len(xpoints)):<br />
        coords.append([xpoints[i], ypoints[i]])</p>
<p>    # Draw curve<br />
    pygame.draw.lines(surface, line_colour, False, coords, 3)</p>
<p>    # Add surface to screen<br />
        screen.blit(surface, (0, 0))</p>
<p>    pygame.display.flip()   </p>
<p>pygame.quit()</p>
<p>[/code]</p>
<p>It works fine, but it's kind of slow... after a bit of searching around decided to go back to the pixel-updating method of the example I followed. Here's the code (<code>standing_wave_4.py</code>):</p>
<p>[code lang=python]<br />
&lt;br /&gt;## Standing wave demonstration with pygame</p>
<p>import pygame<br />
import time<br />
import math</p>
<p># Window size<br />
canvas_width = 640<br />
canvas_height = 480</p>
<p># Define colours<br />
line_colour = pygame.Color(55, 115, 212, 0)<br />
background_colour = pygame.Color(255, 255, 255, 0)</p>
<p># Make screen<br />
screen = pygame.display.set_mode((canvas_width, canvas_height))<br />
screen.fill(background_colour)</p>
<p># Make drawing surface<br />
surface = pygame.Surface((canvas_width, canvas_height)).convert()<br />
surface.fill(background_colour)</p>
<p># Define standing wave function</p>
<p>amplitude = 50 # in px<br />
frequency = 45</p>
<p>def k(n):<br />
    return n*math.pi/canvas_width</p>
<p>def ysummand(x, n):<br />
    return (frequency**2/(k(n)**2-frequency**2))*math.sin(k(n)*(float(x)))</p>
<p>def ysum(x):<br />
    for i in range (1, 10):<br />
        sum = 0<br />
        sum = sum + ysummand(x, i)<br />
        return sum</p>
<p>def y(x):<br />
    return (2/math.pi)*amplitude*ysum(x)</p>
<p>def psi(x):<br />
    return y(x) + amplitude*(1 - (float(x)/canvas_width))</p>
<p>#pygame.init()</p>
<p># Main loop<br />
running = True<br />
while running:<br />
    for event in pygame.event.get():<br />
        if event.type == pygame.QUIT:<br />
            running = False</p>
<p>    # Redraw background<br />
    surface.fill(background_colour)</p>
<p>    for xrange in range(0, canvas_width):<br />
    yrange = int((canvas_height/2) + psi(xrange)*math.cos(frequency*time.time()))<br />
    for i in range(0, 4):<br />
        surface.set_at((xrange, yrange + i), line_colour)</p>
<p>    # Add surface to screen<br />
    screen.blit(surface, (0, 0))</p>
<p>    # Display<br />
    pygame.display.flip()   </p>
<p>pygame.quit()</p>
<p>[/code]</p>
<p>Works OK. Next need to add some interactivity.</p>
<h1>Tuesday 26th August</h1>
<p>Added some very crude interactivity: use left and right arrows to control frequency (using <a href="http://stackoverflow.com/questions/16044229/how-to-get-keyboard-input-in-pygame">this example</a> as a guide), plus some text at the top of the screen displaying the current frequency (based on <a href="http://www.pygame.org/docs/tut/tom/games2.html">this example</a>).</p>
<p>The full code is (<code>standing_wave_5.py</code>):</p>
<p>[code lang=python]<br />
&lt;br /&gt;## Standing wave demonstration with pygame</p>
<p>import pygame<br />
import time<br />
import math</p>
<p># Window size<br />
canvas_width = 640<br />
canvas_height = 480</p>
<p># Define colours<br />
line_colour = pygame.Color(55, 115, 212, 0)<br />
background_colour = pygame.Color(255, 255, 255, 0)<br />
slider_colour = pygame.Color(0, 0, 0, 0)</p>
<p># Make screen<br />
screen = pygame.display.set_mode((canvas_width, canvas_height))<br />
screen.fill(background_colour)</p>
<p># Make drawing surface<br />
surface = pygame.Surface((canvas_width, canvas_height)).convert()<br />
surface.fill(background_colour)</p>
<p># Define standing wave function</p>
<p>amplitude = 80 # in px<br />
frequency = 200<br />
speed = 0.1</p>
<p>def k(n):<br />
    return n*math.pi/canvas_width</p>
<p>def ysummand(x, n):<br />
    return (frequency**2/(k(n)**2-frequency**2))*math.sin(k(n)*(float(x)))</p>
<p>def ysum(x):<br />
    for i in range (1, 10):<br />
        sum = 0<br />
        sum = sum + ysummand(x, i)<br />
        return sum</p>
<p>def y(x):<br />
    return (2/math.pi)*amplitude*ysum(x)</p>
<p>def psi(x):<br />
    return y(x) + amplitude*(1 - (float(x)/canvas_width))</p>
<p>pygame.init()</p>
<p># Main loop<br />
running = True<br />
while running:<br />
    for event in pygame.event.get():<br />
        if event.type == pygame.QUIT:<br />
            running = False</p>
<p>    # Redraw background<br />
    surface.fill(background_colour)</p>
<p>    for xrange in range(0, canvas_width):<br />
    yrange = int((canvas_height/2) + psi(xrange)*math.cos(speed*frequency*time.time()))<br />
    for i in range(0, 4):<br />
        surface.set_at((xrange, yrange + i), line_colour)</p>
<p>    # Display some text<br />
    font = pygame.font.Font(None, 36)<br />
    text = font.render(&quot;Frequency is &quot;+str(abs(frequency)), 1, (10, 10, 10))<br />
    textpos = text.get_rect()<br />
    textpos.centerx = surface.get_rect().centerx<br />
    surface.blit(text, textpos)</p>
<p>    # Add surface to screen<br />
    screen.blit(surface, (0, 0))</p>
<p>    # Display<br />
    pygame.display.flip()</p>
<p>    move_ticker = 0<br />
    keys=pygame.key.get_pressed()<br />
    if keys[pygame.K_LEFT]:<br />
        if move_ticker == 0:<br />
            move_ticker = 10<br />
            frequency -= 0.1<br />
    if keys[pygame.K_RIGHT]:<br />
        if move_ticker == 0:<br />
            move_ticker = 10<br />
            frequency += 0.1</p>
<p>pygame.quit()</p>
<p>[/code]</p>
<p>Took a screenshot (<code>screenshot1</code>)<br />
This could do with some improvements:</p>
<ul>
<li>make it easier to change the frequency a large amount... maybe an editable text box</li>
<li>at the moment when I change the frequency the curve is 'resetting' somehow so that the movement is not smooth.</li>
</ul>
<h1>Thursday 28 September</h1>
<p>calculations</p>
<h1>Monday 1 September</h1>
<p>wrote intro<br />
played with gui library</p>
<h1>Tuesday 2 September</h1>
<p>Bit more playing with gui library, went home early as getting a cold.<br />
Not really sure this is the way I want to go.</p>
<h1>Sunday 7th September</h1>
<p>Realised code was wrong - curve wasn't changing shape with increasing frequency<br />
found one problem - ysummand was not summing correctly and fixed that. still wrong tho.</p>
<p>tested in Mathematica and convinced myself the solution was correct - just not my implementation!</p>
<h1>Monday 8th September</h1>
<p>Found problem after testing various things - something to do with integers and floats. Currently if the frequency increment is a float it breaks, if it is an integer it doesn't. Can also break it by defining the amplitude and speed as floats. Need to go through carefully and work out what needs to be what - tomorrow!</p>
